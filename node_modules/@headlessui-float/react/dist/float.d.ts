import type { Dispatch, ElementType, MutableRefObject, ReactElement, SetStateAction } from 'react';
import { type ExtendedRefs } from '@floating-ui/react';
import type { VirtualElement } from '@floating-ui/core';
import type { DetectOverflowOptions, Middleware, Placement, Strategy } from '@floating-ui/dom';
import type { Options as OffsetOptions } from '@floating-ui/core/src/middleware/offset';
import type { Options as ShiftOptions } from '@floating-ui/core/src/middleware/shift';
import type { Options as FlipOptions } from '@floating-ui/core/src/middleware/flip';
import type { Options as AutoPlacementOptions } from '@floating-ui/core/src/middleware/autoPlacement';
import type { Options as HideOptions } from '@floating-ui/core/src/middleware/hide';
import type { Options as AutoUpdateOptions } from '@floating-ui/dom/src/autoUpdate';
import { type OriginClassResolver } from './origin-class-resolvers';
interface ReferenceState {
    referenceRef: (node: HTMLElement) => void;
    placement: Placement;
}
interface FloatingState {
    floatingRef: (node: HTMLElement) => void;
    props: Omit<FloatProps, 'children' | 'className'>;
    mounted: MutableRefObject<boolean>;
    setShow: Dispatch<SetStateAction<boolean>>;
    x: number | null;
    y: number | null;
    placement: Placement;
    strategy: Strategy;
    referenceElWidth: number | null;
}
export interface FloatProps {
    as?: ElementType;
    floatingAs?: ElementType;
    show?: boolean;
    placement?: Placement;
    strategy?: Strategy;
    offset?: OffsetOptions;
    shift?: boolean | number | Partial<ShiftOptions & DetectOverflowOptions>;
    flip?: boolean | number | Partial<FlipOptions & DetectOverflowOptions>;
    arrow?: boolean | number;
    autoPlacement?: boolean | Partial<AutoPlacementOptions & DetectOverflowOptions>;
    hide?: boolean | Partial<HideOptions & DetectOverflowOptions>;
    autoUpdate?: boolean | Partial<AutoUpdateOptions>;
    zIndex?: number | string;
    enter?: string;
    enterFrom?: string;
    enterTo?: string;
    leave?: string;
    leaveFrom?: string;
    leaveTo?: string;
    originClass?: string | OriginClassResolver;
    tailwindcssOriginClass?: boolean;
    portal?: boolean;
    transform?: boolean;
    adaptiveWidth?: boolean;
    composable?: boolean;
    dialog?: boolean;
    middleware?: Middleware[] | ((refs: {
        referenceEl: MutableRefObject<Element | VirtualElement | null>;
        floatingEl: MutableRefObject<HTMLElement | null>;
    }) => Middleware[]);
    className?: string | ((bag: FloatReferenceRenderProp) => string);
    children: ReactElement[] | ((slot: FloatReferenceRenderProp) => ReactElement[]);
    onShow?: () => void;
    onHide?: () => void;
    onUpdate?: () => void;
}
export declare function renderReferenceElement(ReferenceNode: ReactElement, componentProps: FloatReferenceProps & Required<Pick<FloatReferenceProps, 'as'>>, attrs: Record<string, any>, context: ReferenceState): JSX.Element;
export type RenderFloatingElementProps = FloatContentProps & Required<Pick<FloatContentProps, 'as'>> & {
    show?: boolean | null;
};
export declare function renderFloatingElement(FloatingNode: ReactElement, componentProps: RenderFloatingElementProps, attrs: Record<string, any>, context: FloatingState): JSX.Element;
export interface FloatRenderProp {
    placement: Placement;
}
export interface FloatReferenceProps extends Pick<FloatProps, 'as'> {
    className?: string | ((bag: FloatReferenceRenderProp) => string);
    children?: ReactElement | ((slot: FloatReferenceRenderProp) => ReactElement);
}
export interface FloatReferenceRenderProp {
    placement: Placement;
}
declare function Reference(props: FloatReferenceProps): JSX.Element;
export interface FloatContentProps extends Pick<FloatProps, 'as' | 'enter' | 'enterFrom' | 'enterTo' | 'leave' | 'leaveFrom' | 'leaveTo' | 'originClass' | 'tailwindcssOriginClass'> {
    transitionChild?: boolean;
    className?: string | ((bag: FloatContentRenderProp) => string);
    children?: ReactElement | ((slot: FloatContentRenderProp) => ReactElement);
}
export interface FloatContentRenderProp {
    placement: Placement;
}
declare function Content(props: FloatContentProps): JSX.Element;
export interface FloatArrowProps extends Pick<FloatProps, 'as'> {
    offset?: number;
    className?: string | ((bag: FloatArrowRenderProp) => string);
    children?: ReactElement | ((slot: FloatArrowRenderProp) => ReactElement);
}
export interface FloatArrowRenderProp {
    placement: Placement;
}
declare function Arrow(props: FloatArrowProps): JSX.Element;
export interface FloatVirtualProps extends Pick<FloatProps, 'as' | 'show' | 'placement' | 'strategy' | 'offset' | 'shift' | 'flip' | 'arrow' | 'autoPlacement' | 'hide' | 'autoUpdate' | 'zIndex' | 'enter' | 'enterFrom' | 'enterTo' | 'leave' | 'leaveFrom' | 'leaveTo' | 'originClass' | 'tailwindcssOriginClass' | 'portal' | 'transform' | 'middleware' | 'onShow' | 'onHide' | 'onUpdate'> {
    onInitial: (props: FloatVirtualInitialProps) => void;
    className?: string;
    children?: ReactElement | ((slot: FloatVirtualRenderProp) => ReactElement);
}
export interface FloatVirtualInitialProps {
    show: boolean;
    setShow: Dispatch<SetStateAction<boolean>>;
    placement: Placement;
    refs: ExtendedRefs<HTMLElement>;
}
export interface FloatVirtualRenderProp {
    placement: Placement;
    close: () => void;
}
declare function Virtual({ onInitial, children, ...props }: FloatVirtualProps): JSX.Element;
export interface FloatContextMenuProps extends Omit<FloatVirtualProps, 'show' | 'portal' | 'onInitial'> {
}
declare function ContextMenu(props: FloatContextMenuProps): JSX.Element;
export interface FloatCursorProps extends Omit<FloatVirtualProps, 'show' | 'portal' | 'onInitial'> {
    globalHideCursor?: boolean;
}
declare function Cursor({ globalHideCursor, ...props }: FloatCursorProps): JSX.Element;
export declare const Float: import("react").ForwardRefExoticComponent<FloatProps & import("react").RefAttributes<ElementType<any>>> & {
    Reference: typeof Reference;
    Content: typeof Content;
    Arrow: typeof Arrow;
    Virtual: typeof Virtual;
    ContextMenu: typeof ContextMenu;
    Cursor: typeof Cursor;
};
export {};
